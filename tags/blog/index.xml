<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>blog on 或曰</title><link>https://blog2.issei.org/tags/blog/</link><description>Recent content in blog on 或曰</description><generator>Hugo -- gohugo.io</generator><language>ja</language><lastBuildDate>Mon, 21 Dec 2020 14:59:07 +0100</lastBuildDate><atom:link href="https://blog2.issei.org/tags/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Blog のスタイルシートを Scss に</title><link>https://blog2.issei.org/2020/12/21/hugo-with-scss/</link><pubDate>Mon, 21 Dec 2020 14:59:07 +0100</pubDate><guid>https://blog2.issei.org/2020/12/21/hugo-with-scss/</guid><description>&lt;p>この blog は &lt;a href="https://gohugo.io/">Hugo&lt;/a> を使って生成していますが、
見た目を指定するのに使う CSS ファイルを直接手書きするのではなく、
Scss で書いて CSS ファイルを自動生成するようにしました。&lt;/p>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>CSS ファイルはテキストエディタを使って直接書くこともできますが、
記法に制限が多く煩雑になりがちです。
そこで今は&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://sass-lang.com/">Sass (Syntactically awesome style sheets)&lt;/a> でスタイルを記述し、
それからプログラムで CSS に変換して使うのが一般的&lt;/li>
&lt;li>Sass がサポートする記法には Sass 記法、Scss 記法のふたつがあり、
後者は CSS の上位互換となっているため移行が容易。&lt;/li>
&lt;/ul>
&lt;p>という話は知ってはいたものの、
実は使ったことがありませんでした。&lt;/p>
&lt;h2 id="hugo-の-scss-対応">Hugo の Scss 対応&lt;/h2>
&lt;p>Sass から CSS を作成するツールはいくつかありますが、
Hugo には &lt;a href="https://gohugo.io/hugo-pipes/scss-sass/">Sass/Scss パイプライン&lt;/a> が組み込まれた extended バージョンが存在するため、
それを使うことにしました。&lt;/p>
&lt;ol>
&lt;li>ローカルの Linux on Chromebook 環境には &lt;a href="https://gohugo.io/getting-started/installing/">Install Hugo&lt;/a> の手順に従ってソースコードからインストール。&lt;/li>
&lt;li>次に既存の CSS ファイルを &lt;code>/static/css&lt;/code> から &lt;code>/assets/sass&lt;/code> ディレクトに移動し、
ファイル名の末尾を &lt;code>.css&lt;/code> から &lt;code>.scss&lt;/code> に変更。&lt;/li>
&lt;li>合わせて、レイアウトファイルで CSS をリンクしている部分を書き換えます。&lt;br>
変更前
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-html" data-lang="html">&amp;lt;&lt;span style="color:#f92672">link&lt;/span> &lt;span style="color:#a6e22e">rel&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;stylesheet&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">href&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;/css/getform.css&amp;#34;&lt;/span>&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>変更後&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-html" data-lang="html">{{ $style := resources.Get &amp;#34;sass/getform.scss&amp;#34; | toCSS | minify | fingerprint }}
&amp;lt;&lt;span style="color:#f92672">link&lt;/span> &lt;span style="color:#a6e22e">rel&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;stylesheet&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">href&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;{{ $style.Permalink }}&amp;#34;&lt;/span>&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;p>最初の &lt;code>resources.Get&lt;/code> は Hugo パイプラインにファイルからの読み込みを指示しており、
デフォルトでは &lt;code>/assets&lt;/code> ディレクトリからの相対パスで指定します
（参考: &lt;a href="https://gohugo.io/hugo-pipes/introduction/#from-file-to-resource">Hugo Pipes Introduction: From file to resourc&lt;/a>）。&lt;/p>
&lt;p>ファイルを読み込んで生成したリソースに対して、
&lt;a href="https://gohugo.io/hugo-pipes/scss-sass/">Resource.ToCSS&lt;/a> を適用して SCSS から CSS に変更、
&lt;a href="https://gohugo.io/hugo-pipes/minification/">Resource.Minify&lt;/a> でプログラム的には意味がない改行や空白文字を除去して軽量化、
最後に &lt;a href="https://gohugo.io/hugo-pipes/fingerprint/">Resource.Fingerprint&lt;/a> でファイル名にフィンガープリントをつけ、
内容が変わった際に誤って古いキャッシュを参照し続けることがないようにします。&lt;/p>
&lt;p>メソッド名は正式には Resource + 大文字開始ですが &lt;a href="https://gohugo.io/hugo-pipes/introduction/#method-aliases">Method aliases&lt;/a> が定義されているので、
先頭の &lt;code>Resource.&lt;/code> をとった小文字始まりの名前が使えます。&lt;/p>
&lt;h3 id="次の一歩">次の一歩&lt;/h3>
&lt;p>複数の CSS ファイルを参照していた場合、
Scss の @import を使って一つにまとめることで、
ソースコードレベルでは分割して扱いやすくしつつ、
HTML ファイルからは単一の CSS ファイルにリンクするように変更できます。&lt;/p>
&lt;p>また Scss は CSS 上位互換なのでそのままでも使えますが、
入れ子になった部分や共通部分をくくりだして、
同じ内容を簡略化して書き直すことができます。&lt;/p>
&lt;h2 id="travis-ci-の-scss-対応">Travis CI の Scss 対応&lt;/h2>
&lt;p>このブログは GitHub に変更点を push すると、
Travis CI がそれを検出して自動的にサイトを再構築します。&lt;/p>
&lt;p>サイト再構築の際、
Travis CI 上の Linux インスタンスは &lt;a href="https://docs.travis-ci.com/user/deployment/snaps/">Snap Store&lt;/a> から Hugo をインストールしますが、
ここで Sass/Scss パイプラインが組み込まれた extended バージョンの Hugo を使うように、
設定ファイル &lt;code>.travis.yml&lt;/code> の Hugo パッケージのところに &lt;code>channel: extended&lt;/code> を指定します。&lt;/p>
&lt;p>&lt;strong>.travis.yml&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yml" data-lang="yml">&lt;span style="color:#f92672">addons&lt;/span>:
&lt;span style="color:#f92672">snaps&lt;/span>:
- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">hugo&lt;/span>
&lt;span style="color:#f92672">channel&lt;/span>: &lt;span style="color:#ae81ff">extended&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="todo">TODO&lt;/h2>
&lt;p>&lt;a href="https://sass-lang.com/documentation">Sass のドキュメント&lt;/a> に一通り目を通す。&lt;/p></description></item><item><title>Blog を Firebase にホスティング</title><link>https://blog2.issei.org/2020/09/23/firebase/</link><pubDate>Wed, 23 Sep 2020 20:46:51 +0200</pubDate><guid>https://blog2.issei.org/2020/09/23/firebase/</guid><description>&lt;p>&lt;a href="https://www.netlify.com/">Netlify&lt;/a> の環境がおおよそ分かったところで、
今度は &lt;a href="https://firebase.google.com/">Firebase&lt;/a> を使ってみました。
最初は Jekyll を使ってローカルにサイトを構築した上で手作業でデプロイして動作確認を行い、
次に &lt;a href="https://travis-ci.com/">Travis CI&lt;/a> を使って自動デプロイできるようにします。&lt;/p>
&lt;p>今回はとりあえずパイプラインを作ってみるのが目的なので、
競合サービスとの比較検討などはしてません。&lt;/p>
&lt;h2 id="サービスの概要">サービスの概要&lt;/h2>
&lt;h3 id="firebase">&lt;a href="https://firebase.google.com/">Firebase&lt;/a>&lt;/h3>
&lt;p>今回は静的サイトのホスティングに使うだけですが、
Firebase は認証やストレージを含めた Web、モバイルアプリケーション構築のためのバックエンドサービスを幅広く提供しています。
Firebase は2014年に Google に買収され、
現在は Google のインフラに統合されています。&lt;/p>
&lt;p>競合サービス: &lt;a href="https://aws.amazon.com">Amazon Web Service&lt;/a>, &lt;a href="https://azure.microsoft.com/">Microsoft Azure&lt;/a>&lt;/p>
&lt;h3 id="travis-ci">&lt;a href="https://travis-ci.com/">Travis CI&lt;/a>&lt;/h3>
&lt;p>GitHub と連携して使える継続的インテグレーション (CI) サービスで、
GitHub 上のリポジトリへの push や pull リクエストをトリガーとして、
指定したリポジトリ上のファイルを自動的に取得してビルドやテストを実行するサービスです。&lt;/p>
&lt;p>GitHub の公開リポジトリに対して使う分には無料で利用できますが、
Travis CI のビルドログや設定ファイルも公開されます。
非公開リポジトリと連携する場合には有料。&lt;/p>
&lt;p>競合サービス: &lt;a href="https://circleci.com">Circle CI&lt;/a>, &lt;a href="https://buddy.works/">Buddy&lt;/a>, &lt;a href="https://www.jenkins.io/">Jenkins&lt;/a>&lt;/p>
&lt;h2 id="環境構築">環境構築&lt;/h2>
&lt;h3 id="firebase-に手作業でデプロイ">Firebase に手作業でデプロイ&lt;/h3>
&lt;p>まずは手元のマシンでサイトを構築し、
それを手作業で Firebase にデプロイします。&lt;/p>
&lt;p>手元ではサイト構築が完了して &lt;code>_site&lt;/code> ディレクトリ以下のファイルを転送するだけという状態から、
Firebase にデプロイするまでの手順は次のようになります。&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://console.firebase.google.com/">Firebase のコンソール&lt;/a> からプロジェクトを作成します。&lt;/li>
&lt;li>firebase 上のプロジェクトを管理するためにコマンドラインツール Firebase CLI をインストールします。&lt;br>
参考: &lt;a href="https://firebase.google.com/docs/cli?hl=ja#install_the_firebase_cli">Firebase CLI リファレンス - CLI を設定または更新する&lt;/a>&lt;br>
&lt;pre>&lt;code>% curl -sL https://firebase.tools | bash
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>Firebase にログインします。
&lt;pre>&lt;code>% firebase login
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>ブログのトップディレクトリに移動し、
そのディレクトリを Firebase に転送するための&lt;a href="https://firebase.google.com/docs/hosting/quickstart">初期設定を行います&lt;/a>。
ホスティングを選択して、公開ルートディレクトリとして &lt;code>_site&lt;/code> を選択します。
&lt;pre>&lt;code>% firebase init
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>.firebaserc と firebase.json というファイルが作成されるので、このうち後者を表示して &lt;code>_site&lt;/code> 以下のディレクトリのみ転送するように設定されていることを確認します。
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-json" data-lang="json"> {
&lt;span style="color:#f92672">&amp;#34;hosting&amp;#34;&lt;/span>: {
&lt;span style="color:#f92672">&amp;#34;public&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;_site&amp;#34;&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;ignore&amp;#34;&lt;/span>: [
&lt;span style="color:#e6db74">&amp;#34;firebase.json&amp;#34;&lt;/span>,
&lt;span style="color:#e6db74">&amp;#34;**/.*&amp;#34;&lt;/span>,
&lt;span style="color:#e6db74">&amp;#34;**/node_modules/**&amp;#34;&lt;/span>
]
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>転送後のサイトをプレビューして、意図通りのファイルが転送されているか確認します。
&lt;pre>&lt;code>% firebase serve
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>ファイルを Firebase に転送します。
&lt;pre>&lt;code>% firebase deploy
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;p>これで Firebase の URL https://プロジェクト名.web.app/ でサイトが表示されたら、
Firebase 側の設定は完了です。&lt;/p>
&lt;h2 id="travis-ci-1">Travis CI&lt;/h2>
&lt;h3 id="継続的ビルド設定">継続的ビルド設定&lt;/h3>
&lt;p>次に &lt;a href="https://travis-ci.com/">Travis CI&lt;/a> を介して、
ブログの記事や設定ファイルなどを GitHub リポジトリに push するとサイトを自動的に構築・デプロイするようにします。&lt;/p>
&lt;p>個人のブログ程度だと、
ここまで環境を作っても得られるメリットは限られますが、
複数人で同一のブログに別々の記事を投稿したり記事を公開する前にレビューする場合には、
競合を解決したり事前レビューのためのフローを簡単に作成できます。&lt;/p>
&lt;p>公式の &lt;a href="https://docs.travis-ci.com/user/tutorial/">Travis CI Tutorial&lt;/a> を読んで、
その手順に従います。&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://travis-ci.com/">Travis CI&lt;/a> のページから Sign up を選択し、GitHub アカウントでサインアップします。&lt;/li>
&lt;li>表示される手順に従って、GitHub 上の情報に Travis CI からアクセスすることを許可します。&lt;/li>
&lt;li>&lt;code>.travis.yml&lt;/code> ファイルをブログのリポジトリのトップディレクトリに追加します。
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yml" data-lang="yml"> &lt;span style="color:#f92672">dist&lt;/span>: &lt;span style="color:#ae81ff">focal&lt;/span>
&lt;span style="color:#f92672">language&lt;/span>: &lt;span style="color:#ae81ff">ruby&lt;/span>
&lt;span style="color:#f92672">rvm&lt;/span>: &lt;span style="color:#ae81ff">2.7.1&lt;/span>
&lt;span style="color:#75715e"># Assume bundler is being used, therefore&lt;/span>
&lt;span style="color:#75715e"># the `install` step will run `bundle install` by default.&lt;/span>
&lt;span style="color:#f92672">script&lt;/span>: &lt;span style="color:#ae81ff">bundle exec jekyll build&lt;/span>
&lt;span style="color:#75715e"># branch whitelist, only for GitHub Pages&lt;/span>
&lt;span style="color:#f92672">branches&lt;/span>:
&lt;span style="color:#f92672">only&lt;/span>:
- &lt;span style="color:#ae81ff">master&lt;/span>
&lt;span style="color:#f92672">env&lt;/span>:
&lt;span style="color:#f92672">global&lt;/span>:
- &lt;span style="color:#ae81ff">JEKYLL_ENV=production&lt;/span>
&lt;span style="color:#f92672">cache&lt;/span>: &lt;span style="color:#ae81ff">bundler&lt;/span> &lt;span style="color:#75715e"># caching bundler gem packages will speed up build&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>Travis CI の &lt;a href="https://travis-ci.com/dashboard">ダッシュボード&lt;/a> からブログのリポジトリを選択し、
ビルドが正常に終了することを確認します。&lt;/li>
&lt;/ol>
&lt;h3 id="設定内容解説">設定内容解説&lt;/h3>
&lt;p>今回は Ruby で書かれたツール Jekyll で静的サイトを構築します。&lt;/p>
&lt;p>手元の環境が Ruby 2.7.1 だったので、
ビルド環境との差異を減らすため同一バージョンの Ruby を使うことにし、
Ruby 2.7.1 がプリインストールされている Linux 環境の focal を選択しました。&lt;/p>
&lt;p>参考: &lt;a href="https://docs.travis-ci.com/user/languages/ruby">Building a Ruby Project&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yml" data-lang="yml">&lt;span style="color:#f92672">dist&lt;/span>: &lt;span style="color:#ae81ff">focal&lt;/span>
&lt;span style="color:#f92672">language&lt;/span>: &lt;span style="color:#ae81ff">ruby&lt;/span>
&lt;span style="color:#f92672">rvm&lt;/span>: &lt;span style="color:#ae81ff">2.7.1&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Gemfile&lt;/code> が Git リポジトリに含まれている場合、
Travis CI は Bundler を使って必要なパッケージをインストールするため、
自分でインストール手順を指示する必要はありません。
サイトのビルド方法のみ指定します。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yml" data-lang="yml">&lt;span style="color:#f92672">script&lt;/span>: &lt;span style="color:#ae81ff">bundle exec jekyll build&lt;/span>
&lt;span style="color:#f92672">env&lt;/span>:
&lt;span style="color:#f92672">global&lt;/span>:
- &lt;span style="color:#ae81ff">JEKYLL_ENV=production&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>あとは設定ファイル中のコメントの通りです。&lt;/p>
&lt;h3 id="デプロイ設定">デプロイ設定&lt;/h3>
&lt;p>ビルドが問題なく行えるようになったら、
次に構築したサイトを Firebase に転送するための設定を &lt;code>.travis.yml&lt;/code> に追加します。&lt;/p>
&lt;p>参考: &lt;a href="https://docs.travis-ci.com/user/deployment/firebase/#generating-your-firebase-token">Firebase Deployment&lt;/a>&lt;/p>
&lt;ol>
&lt;li>Travis CI から Firebase にファイルを転送する際に、
正当なユーザーであることを示すトークンを作成します。
&lt;pre>&lt;code>% firebase login:ci
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>このトークンをそのまま設定ファイルに記述すると GitHub リポジトリを見たユーザーがトークンを再利用できてしまうため、
Travis CI からのみ使えるように暗号化します。
&lt;pre>&lt;code>% gem install travis
% travis encrypt &amp;quot;得られたトークン&amp;quot;
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;code>.travis.yml&lt;/code> に deploy セクションを追加します。
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yml" data-lang="yml">&lt;span style="color:#f92672">deploy&lt;/span>:
&lt;span style="color:#f92672">provider&lt;/span>: &lt;span style="color:#ae81ff">firebase&lt;/span>
&lt;span style="color:#f92672">token&lt;/span>:
&lt;span style="color:#f92672">secure&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;oSfN...&amp;#34;&lt;/span> &lt;span style="color:#75715e"># travis encrypt で得られた暗号化トークン&lt;/span>
&lt;span style="color:#f92672">skip_cleanup&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>デフォルトでは Travis CI は、
デプロイ開始前に作成されたファイルをすべて削除します。
今回はそれだと困るので skip_cleanup を指定します。&lt;br>
参考: &lt;a href="https://docs.travis-ci.com/user/deployment/#uploading-files-and-skip_cleanup">Uploading Files and skip_cleanup&lt;/a>&lt;/p>
&lt;/li>
&lt;li>(オプション) ビルド成功・失敗時に通知する条件と通知先を設定します。
私は Slack に専用のチャンネルを作成し、そこに通知するようにしました。&lt;br>
参考: &lt;a href="https://docs.travis-ci.com/user/notifications/#configuring-slack-notifications">Deployment - Configuring Build Notifications&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="雑感">雑感&lt;/h2>
&lt;p>Netlify は CDN を持っていますが、
Firebase と比べるとスイスからアクセスするのが遅いです。
人間の目でも、
画像が読み込まれて上から徐々に表示されるのが見えます
（ベンチマークを取った結果もありますが、
計測条件が適当すぎるので略）。&lt;/p>
&lt;p>一方で、
設定の容易さは Netlify が圧倒的です。
もともと Travis CI は静的サイトのホスティングのためのサービスではなく、
継続的ビルド・テスト・デプロイのための汎用プラットフォームなので、
柔軟な設定が可能ですが、
その裏返しとして最低限の設定項目が多いです
（まだドキュメントを読みきれてない）。&lt;/p>
&lt;p>あとは必ずしも Netlify の問題ではないですが、
静的サイト構築に Jekyll を使うと、
ページ数が増えるとサイトの構築に時間がかかるようになります。
Netlify の無料プランは月300分までなので、
複数人で作業するサイトだと超える可能性があります。&lt;/p>
&lt;p>規模が大きくなることが想定される場合には、
Python, Ruby や JavaScript といったインタプリタ言語ではなく、
たとえば Go 言語で書かれた &lt;a href="https://gohugo.io/">Hugo&lt;/a> などを使うほうが良いかもしれません。&lt;/p></description></item><item><title>Blog を Netlify にホスティング</title><link>https://blog2.issei.org/2020/09/20/blog-hosting-on-netlify/</link><pubDate>Sun, 20 Sep 2020 21:28:06 +0200</pubDate><guid>https://blog2.issei.org/2020/09/20/blog-hosting-on-netlify/</guid><description>&lt;p>ブログのホスティング先を &lt;a href="https://pages.github.com/">GitHub Pages&lt;/a> から &lt;a href="https://www.netlify.com/">Netlify&lt;/a> に切り替えました。
評判が良い Netlify を実際に試して評価するため。&lt;/p>
&lt;h2 id="netlify-を利用する利点">Netlify を利用する利点&lt;/h2>
&lt;p>Netlify の公式サイトでも &lt;a href="https://www.netlify.com/github-pages-vs-netlify/">GITHUB PAGES VS. NETLIFY&lt;/a> という比較ページがありますが、
付け加えて二点。&lt;/p>
&lt;p>GitHub Pages では現時点で &lt;a href="https://www.jekyllrb.com/">Jekyll&lt;/a> のバージョンは 3.9.0 に固定されており、
使用できるプラグインも限定されています。
一方 Netlify では各サイトのビルドを独立した環境で行うため、
このような制約がありません。&lt;/p>
&lt;p>また Netlify ではデプロイ時のログを見ることができるため、
トラブルシューティングがしやすいです。&lt;/p>
&lt;p>GitHub Pages はローカルに静的サイト構築フレームワークをインストールしなくても使えるため手軽ですが、
ある程度使い込むとなると Netlify の方が良いですね。&lt;/p>
&lt;h2 id="netlify-の使い勝手">Netlify の使い勝手&lt;/h2>
&lt;p>まだ GitHub Pages から移行して基本的な設定をした程度ですが、
Netlify は UI が直感的で迷うところがないです。&lt;/p>
&lt;p>サイトをロールバックしたり、
プレビュー用のブランチを作成したり、
第三者からの pull request を受け付ける場合に自動的にプレビューを作成する機能などもあり、
プロダクション環境での運用でも便利そう。&lt;/p>
&lt;p>もう少し使い込んでみる予定。&lt;/p>
&lt;h2 id="移行作業">移行作業&lt;/h2>
&lt;h3 id="github-pages-から-netlify-への移行">GitHub Pages から Netlify への移行&lt;/h3>
&lt;p>ローカルで Jekyll を実行できるようにしてある場合、
Netlify のセットアップは簡単です。&lt;/p>
&lt;p>GitHub にあるリポジトリとブランチを選択し、
ホスト名などを設定するだけ。
Netlify の側で Jekyll を使ったサイトには標準で対応しているので、
自動的にビルドコマンドや公開するディレクトリなどが設定され、
手作業で修正を加える場所はほとんどありません。
大袈裟ではなく、
マウス数クリックで終了です。&lt;/p>
&lt;p>カスタムドメインを使用している場合には、
追加でドメイン名の設定と、
DNS の CNAME を Netlify に向ける必要があります。&lt;/p>
&lt;p>なお Jekyll を使っていて本番用（公開用）のサイトを構築している場合には、
Netlify のビルド設定で環境変数 &lt;code>JEKYLL_ENV&lt;/code> を &lt;code>production&lt;/code> に設定する必要があります。
さもないとテスト環境とみなされて、
ログ解析用のタグなどが出力されません。&lt;/p>
&lt;p>&lt;strong>Setting - Build &amp;amp; Deploy - Environment&lt;/strong>
&lt;img src="https://blog2.issei.org/assets/2020/09/blog-hosting-on-netlify/netlify_jekyll_env.png" alt="">&lt;/p>
&lt;h3 id="github-pages-のクリーンアップ">GitHub Pages のクリーンアップ&lt;/h3>
&lt;p>これまでは GitHub 上のリポジトリ isseis.github.io に push すると、
GitHub が自動的に変更をピックアップして対応する GitHub Pages を更新していましたが、
Netlify への移行に伴ってこれが不要になります。&lt;/p>
&lt;p>GitHub リポジトリの設定で GitHub Pages の更新を止めようとしたところ、
うまくいかない。
調べたところ GitHub Community で解決策を見つけました。&lt;/p>
&lt;p>&lt;a href="https://github.community/t/cant-disable-github-pages-for-this-repository/126156/4">Can’t disable GitHub Pages for this repository&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>GitHub Pages sites served from repositories that use the special naming scheme username.github.io can’t be unpublished as it’s expected that a Pages site will be served from these repos. In order to disable Pages for these repositories you’ll need to first rename it to something else.&lt;/p>
&lt;/blockquote>
&lt;p>リポジトリの名前を変更し、
Setting - GitHub Pages - Sources を None に変更して完了。&lt;/p></description></item><item><title>静的 Web コンテンツ作成・配信環境</title><link>https://blog2.issei.org/2020/09/12/hosting-static-web-contents/</link><pubDate>Sat, 12 Sep 2020 17:40:42 +0200</pubDate><guid>https://blog2.issei.org/2020/09/12/hosting-static-web-contents/</guid><description>&lt;p>久しぶりにブログ（というか往年の Web 日記というか）を書き始めて、
あらためて静的なコンテンツを作成し Web で公開するための環境について調べています。&lt;/p>
&lt;p>ここ10年ぐらいバックエンドやモバイル関係の仕事が主だったので、
Web のフロントエンド系の知識が更新されてませんでした。
多少なりとも実際に使ってから調べると、理解が早い。&lt;/p>
&lt;h2 id="コンテンツ作成">コンテンツ作成&lt;/h2>
&lt;h3 id="背景">背景&lt;/h3>
&lt;p>静的な Web コンテンツを配信するだけなら、原始的には&lt;/p>
&lt;ol>
&lt;li>Linux マシンを一台用意して&lt;/li>
&lt;li>Apache をインストール&lt;/li>
&lt;li>HTML を手書きして index.html ファイルを作る&lt;/li>
&lt;li>Linux マシンの適当なディレクトリに index.html ファイルを置く&lt;/li>
&lt;li>Linux マシンをインターネットに繋ぐ&lt;/li>
&lt;/ol>
&lt;p>だけで動きます。&lt;/p>
&lt;p>HTML を CSS, Javascript と合わせて手書きすることは可能ですが、
やりたいことに対して記述量が増えて大変です。
単一ページの作成だけでなく Web サイトを構成するという観点だと、
たとえばブログで新規エントリを書く度に「最新エントリ一覧」も合わせて手作業で更新することになり、
だんだん辛くなってきます。&lt;/p>
&lt;p>静的な Web コンテンツが主体であっても、
一部には動的な要素を入れたくなることがあります。
たとえばブログにユーザからのコメント欄を設ける場合、
完全に静的な作りだとコメントを即時に表示することはできず、
一旦コメントを製作者が受け取った上で、
それを手作業でコンテンツに反映することになります。&lt;/p>
&lt;h3 id="フロントエンドスタック">フロントエンドスタック&lt;/h3>
&lt;p>そこで人間は本質的なコンテンツ作成に注力し、
それ以外の部分は自動的に処理できるようにしたくなりますが、
そのためのフロントエンドスタックの構成方法の一つとして &lt;a href="https://jamstack.org/">Jamstack&lt;/a> があります。&lt;/p>
&lt;p>Jam は Javascript + API + Markup の意味ですが、これは大きく二つに分けられます。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>技術&lt;/th>
&lt;th>コンテンツの種類&lt;/th>
&lt;th>意味&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Javascript + API&lt;/td>
&lt;td>動的コンテンツ&lt;/td>
&lt;td>クライアントから外部のマイクロサービスを呼び出す&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Markup&lt;/td>
&lt;td>静的コンテンツ&lt;/td>
&lt;td>事前に HTML, CSS などを作成しておく&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>このブログは &lt;a href="https://jekyllrb.com/">Jekyll&lt;/a> + &lt;a href="https://pages.github.com/">GitHub Pages&lt;/a> で作っていますが、
これがまさに Jasmstack の例。
以前に &lt;a href="https://github.com/tdiary">tDiary&lt;/a> という Web 日記システムを使っていたことがありますが、
比較すると構成の違いが分かりやすいです。&lt;/p>
&lt;h4 id="markup">Markup&lt;/h4>
&lt;p>マークアップは文書の構造（見出し、段落、リンクなど）を定義することですが、
Web の世界だと文書を HTML で記述することほぼ同義です。&lt;/p>
&lt;p>&lt;a href="https://jekyllrb.com/">Jekyll&lt;/a> と &lt;a href="https://github.com/tdiary">tDiary&lt;/a> いずれも、
エントリを書くときには人間が書きやすい記法を使いますが、
そのままではブラウザに表示できないため、
どこかのタイミングで HTML に変換する必要があります。&lt;/p>
&lt;p>&lt;a href="https://github.com/tdiary">tDiary&lt;/a> (非jamstack) では変換前のエントリとプログラムを配信サーバに配置し、
ブラウザからアクセスがあった時点で配信サーバー上でプログラムが HTML を作成してブラウザに送ります。&lt;/p>
&lt;p>&lt;img src="https://blog2.issei.org/assets/2020/09/jamstack/contents-building-tdiary.png" alt="tDiary コンテンツ作成フロー">&lt;/p>
&lt;p>この方法には利点も多いのですが、一方で次のような欠点もあります。&lt;/p>
&lt;ul>
&lt;li>コンテンツ配信サーバー上でプログラムを実行する
&lt;ul>
&lt;li>セキュリティ上の問題を生じやすい。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>コンテンツが動的に作成される
&lt;ul>
&lt;li>CDN を使えないため、ユーザがアクセスするのに時間がかかる。&lt;/li>
&lt;li>アクセス数に比例してビルド回数が増え、サーバーの処理能力が必要になる。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://jekyllrb.com/">Jekyll&lt;/a> (jamstack) では先に簡易記法で記述したエントリを HTML に変換し、
変換済みの HTML ファイルを配信サーバーに配置します。&lt;/p>
&lt;p>&lt;img src="https://blog2.issei.org/assets/2020/09/jamstack/contents-building-jamstack.png" alt="Jekyllコンテンツ作成フロー">&lt;/p>
&lt;p>このデザインでは &lt;a href="https://github.com/tdiary">tDiary&lt;/a> の場合の欠点が解消していることが分かります。&lt;/p>
&lt;ul>
&lt;li>ビルドサーバー上でプログラムを実行する
&lt;ul>
&lt;li>ビルドサーバーにはコンテンツ制作者のみアクセスできれば良いため、セキュリティ上の問題が生じにくい。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>コンテンツが静的に作成される
&lt;ul>
&lt;li>CDN を使ってユーザに近いサーバーにコンテンツを置いて置けるため、アクセスが高速になる。&lt;/li>
&lt;li>アクセス数によらずビルド回数は一定なので、サーバーの処理能力を増強する必要がない。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>なお HTML への変換処理はコンテンツ制作者の手元の PC で行うこともできますが、
そうすると PC が単一障害点になり、
また環境依存の問題も起きやすいので、
ビルド環境を別に用意した方が良いです。&lt;/p>
&lt;h4 id="javascript--api">Javascript + API&lt;/h4>
&lt;p>ページ中で動的な処理を行いたい場合、
たとえばブログにリアルタイムで投稿を反映可能なコメント欄を設置する方法。&lt;/p>
&lt;p>&lt;a href="https://github.com/tdiary">tDiary&lt;/a> では配信サーバー上に置かれたプログラムがコメントを管理します。
HTML を作成するときにコメントのデータを取得して埋め込みます。&lt;/p>
&lt;p>&lt;img src="https://blog2.issei.org/assets/2020/09/jamstack/dynamic-contents-tdiary.png" alt="tDiary 動的コンテンツレンダリングフロー">&lt;/p>
&lt;p>このデザインではコンテンツ配信サーバー上でプログラムを動かす必要があり、
上記の &lt;a href="#markup">Markup&lt;/a> での欠点がそのまま残ります。&lt;/p>
&lt;p>またコメントのデータの保存方法についても、
単にサーバー側のローカルディスクに置くとハードディスクトラブルなどで容易に失われてしまいます。
別途データベースサーバーなどを用意することも考えられますが、
今度はデータベースサーバーの設定・運用コストが大きくなります。&lt;/p>
&lt;p>&lt;a href="https://jekyllrb.com/">Jekyll&lt;/a> では配信サーバーとは別に、
コメントだけを管理する &lt;a href="https://disqus.com/home/settings/account/">Disqus&lt;/a> などの外部サービスを利用します。
配信サーバーからは Javascript で記述された外部サーバーと通信するための小さなプログラムを送り、
実際のコメントの取得と表示、投稿などはクライアントが外部サーバーと通信して行います。&lt;/p>
&lt;p>&lt;img src="https://blog2.issei.org/assets/2020/09/jamstack/dynamic-contents-jamstack.png" alt="Jekyll 動的コンテンツレンダリングフロー">&lt;/p>
&lt;p>コンテンツサーバー上にはプログラムを設置することなく、
ユーザには動的なコンテンツを含んだ Web ページを提供することができます。
また外部サービスの追加も容易です。&lt;/p>
&lt;h3 id="静的サイト構築フレームワーク">静的サイト構築フレームワーク&lt;/h3>
&lt;p>GitHub で人気があるもの上位。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>フレームワーク名&lt;/th>
&lt;th>プログラミング言語&lt;/th>
&lt;th>フレームワーク&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;a href="https://nextjs.org/">Next.js&lt;/a>&lt;/td>
&lt;td>Javascript&lt;/td>
&lt;td>React&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://www.gatsbyjs.com/">Gatsby&lt;/a>&lt;/td>
&lt;td>Javascript&lt;/td>
&lt;td>React&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://nuxtjs.org/">Nuxt&lt;/a>&lt;/td>
&lt;td>Javascript&lt;/td>
&lt;td>Vue.js&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://gohugo.io/">Hugo&lt;/a>&lt;/td>
&lt;td>Golang&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://jekyllrb.com/">Jekyll&lt;/a>&lt;/td>
&lt;td>Ruby&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>個人的には &lt;a href="https://jekyllrb.com/">Jekyll&lt;/a> しか使ったことはないですが、
後で他も見てみたいです。&lt;/p>
&lt;h2 id="コンテンツ配信">コンテンツ配信&lt;/h2>
&lt;p>サイトを構築したら、
インターネット上のサイトに置いてアクセス可能にする必要があります。&lt;/p>
&lt;h3 id="静的サイト向けホスティングサービス">静的サイト向けホスティングサービス&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://www.netlify.com/">Netlify&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://pages.github.com/">GitHub Pages&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>静的サイト向けのホスティングサービスなので、
ロードバランシングや CDN などは相手におまかせ。&lt;/p>
&lt;p>GitHub からの継続的インテグレーション、継続的デプロイメント (CI/CD) に対応しているので、&lt;/p>
&lt;ol>
&lt;li>GitHub にリポジトリを作っておいてコンテンツはそこに push&lt;/li>
&lt;li>リポジトリの変更をトリガとして、ホスティングサービス側でサイトのビルドを開始&lt;/li>
&lt;li>ビルドしたコンテンツを配信サーバ上に配置&lt;/li>
&lt;/ol>
&lt;p>というフローを簡単に作れます。&lt;/p>
&lt;p>&lt;a href="https://pages.github.com/">GitHub Pages&lt;/a> は &lt;a href="https://jekyllrb.com/">Jekyll&lt;/a> で作成したコンテンツの配信先としてカジュアルに使うには良いですが、
本格的に使おうとすると制約が多いです。&lt;/p>
&lt;h3 id="クラウドストレージ">クラウドストレージ&lt;/h3>
&lt;p>汎用のクラウドストレージにファイルを置いて、
それにロードバランサーや CDN を組み合わせることで、
サイトを構築することができます。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.aws.amazon.com/s3/index.html">AWS S3&lt;/a> + &lt;a href="https://aws.amazon.com/de/cloudfront/">CloudFront&lt;/a>&lt;/li>
&lt;li>Azure Storage (&lt;a href="https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-static-website">Static website hosting in Azure Storage&lt;/a>)&lt;/li>
&lt;li>&lt;a href="https://cloud.google.com/storage/docs/hosting-static-website">Google Cloud Storage + Cloud Load Balancing&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="技術的背景">技術的背景&lt;/h2>
&lt;p>&lt;a href="https://jamstack.org/">Jamstack&lt;/a> のコンセプトが広まったのは2017年からのようですが、
それまではアイデアとしてはあっても技術的に現実的ではなかったんでしょうかね。&lt;/p>
&lt;p>基盤として、次のような前提が成り立って初めて、今の形の静的サイト構築＋動的コンテンツ埋め込みが可能になります。&lt;/p>
&lt;ul>
&lt;li>ソースコードのホスティング先として GitHub が安定したサービスを提供&lt;/li>
&lt;li>コンテナ仮想化により CI/CD が低コスト・高速に行えるように&lt;/li>
&lt;li>安価に CDN を使えるように&lt;/li>
&lt;li>Javascript フレームワークならびにブラウザが熟成し、マイクロサービスを組み合わせて使うのが容易に&lt;/li>
&lt;/ul></description></item><item><title>ブログのデザインテーマを minimal-mistakes に変更</title><link>https://blog2.issei.org/2020/09/11/change-theme-to-minimal-mistake/</link><pubDate>Fri, 11 Sep 2020 01:42:16 +0200</pubDate><guid>https://blog2.issei.org/2020/09/11/change-theme-to-minimal-mistake/</guid><description>&lt;p>このブログは &lt;a href="https://jekyllrb.com/">Jekyll&lt;/a> を使って作成していますが、
レイアウトテーマを標準の minima から &lt;a href="https://mmistakes.github.io/minimal-mistakes/">minimal-mistakes&lt;/a> に変更しました。&lt;/p>
&lt;p>簡単なコメントを書けるフォームでも用意しようかと思ったのですが、
minima だと既存の設定だけでカスタマイズするのは無理で、
テンプレートファイル自体を編集する必要があります。
それならいっそ設定を柔軟に変更できて、
デザインも今時のテーマファイルに切り替えてしまおうということで。&lt;/p></description></item><item><title>位置情報がある写真を公開する前に警告</title><link>https://blog2.issei.org/2020/09/02/warn-exif/</link><pubDate>Wed, 02 Sep 2020 22:58:52 +0200</pubDate><guid>https://blog2.issei.org/2020/09/02/warn-exif/</guid><description>&lt;p>先日のブログに載せた写真、
調べてみたらジオタグで撮影箇所の緯度・経度が埋まったままでした 🤦‍♂&lt;/p>
&lt;p>さすがに自宅の場所を公開したくはないので、
Git リポジトリから元の写真を削除し、
ジオタグを削除したファイルで置き換えました。
また再発防止のため、
位置情報がある写真をコミットする前に警告を出すように設定しました。&lt;/p>
&lt;p>仕事以外で、
たまに Apps Script とか、
こういう小さなツールを書くのは楽しいですね。&lt;/p>
&lt;h2 id="git-リポジトリから写真を削除">Git リポジトリから写真を削除&lt;/h2>
&lt;p>Git リポジトリから削除する方法に関しては、
こちらの記事を参考にしました。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.karakaram.com/git-rebase-i-usage/#edit">あのコミットをなかった事に。git rebase -i の使い方&lt;/a>&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>% git rebase -i 問題のコミットの直前のハッシュ値
&lt;/code>&lt;/pre>&lt;p>これでエディタが開き、
問題のコミットから最新のコミットまでどうするかを聞かれるので、
問題のコミットだけ edit にして残りは pick のままにしておきます。&lt;/p>
&lt;p>ファイルを保存してエディタを閉じると、
指定したコミット直後の状態になっているので、
画像を削除して rebase を継続します。&lt;/p>
&lt;pre>&lt;code>% git rm 位置情報入りの写真.jpg
% git rebase --continue
&lt;/code>&lt;/pre>&lt;p>GitHub にあるリポジトリとローカルリポジトリが不整合になるため、
ローカルリポジトリのデータで強制的に上書きします。&lt;/p>
&lt;pre>&lt;code>% git push -f
&lt;/code>&lt;/pre>&lt;p>（なお、複数人で開発しているときにこれをやるとリポジトリを壊します）&lt;/p>
&lt;h2 id="位置情報がある写真に対して警告を出す">位置情報がある写真に対して警告を出す&lt;/h2>
&lt;p>Git は commit 直前にスクリプトを走らせる機能があるので、
これを使って、
追加・変更されたファイルにジオタグが埋まっていないかをチェックします。&lt;/p>
&lt;h3 id="_toolscheck_geotagpyhttpsgithubcomisseisblogblobcheck_geo_tag_v002_toolscheck_geotagpy">&lt;a href="https://github.com/isseis/blog/blob/check_geo_tag_v0.0.2/_tools/check_geotag.py">_tools/check_geotag.py&lt;/a>&lt;/h3>
&lt;p>まずは Python を使って、
簡単なスクリプトを作成。&lt;/p>
&lt;ol>
&lt;li>&lt;code>git diff&lt;/code> を使って、変更されたファイルの一覧を取得&lt;/li>
&lt;li>変更されたファイルが JPEG ファイルだった場合、exiftool という外部コマンドを呼び出して EXIF データを取得。&lt;/li>
&lt;li>EXIF データに位置情報があるか調べる。&lt;/li>
&lt;/ol>
&lt;p>テストの際には &lt;code>git diff&lt;/code> の出力を使っていると面倒なので、
コマンドラインから写真のファイル名を指定できるようにしてあります。&lt;/p>
&lt;h3 id="_toolstesthttpsgithubcomisseisblogtreecheck_geo_tag_v002_toolstest">&lt;a href="https://github.com/isseis/blog/tree/check_geo_tag_v0.0.2/_tools/test">_tools/test&lt;/a>&lt;/h3>
&lt;p>関数レベルでの単体テストと、
あとは実際の画像ファイルと exiftool を使ってスクリプトの終了コードを調べるテスト。&lt;/p>
&lt;p>また &lt;a href="http://mypy-lang.org/">mypy&lt;/a> を使って、
Python スクリプトに対して静的型検査を行っています。&lt;/p>
&lt;h3 id="post-commithttpsgithubcomisseisblogblobcheck_geo_tag_v002_toolshookspre-commit">&lt;a href="https://github.com/isseis/blog/blob/check_geo_tag_v0.0.2/_tools/hooks/pre-commit">post-commit&lt;/a>&lt;/h3>
&lt;p>&lt;code>git commit&lt;/code> 実行時に上記の Python スクリプトが実行されるように、
&lt;code>.git/hooks/post-commit&lt;/code> ファイルを作成します。&lt;/p>
&lt;p>.git 以下のファイルは Git で管理できないので、
開発中のスクリプトは &lt;code>_tools/hooks&lt;/code> に置いて、
最初の一回だけ手作業でコピー。
二度目以降は、
post-commit が自動的に最新版をコピーしてくるようにしました。&lt;/p>
&lt;p>参考: &lt;a href="https://tech.appbrew.io/entry/2020/05/15/132413#pre-commit%E3%82%92Git%E3%81%A7%E7%AE%A1%E7%90%86%E3%81%99%E3%82%8B">pre-commitをGitで管理する&lt;/a>&lt;/p>
&lt;h3 id="readmehttpsgithubcomisseisblogblobcheck_geo_tag_v002readmemd">&lt;a href="https://github.com/isseis/blog/blob/check_geo_tag_v0.0.2/README.md">README&lt;/a>&lt;/h3>
&lt;p>使い方を忘れそうなので、
最後に README を書いて終了。&lt;/p>
&lt;h3 id="備考-mypy-のインストール方法">備考: mypy のインストール方法&lt;/h3>
&lt;p>get-pip.py を &lt;a href="https://pip.pypa.io/en/stable/installing/">Python Packaging Authority&lt;/a> から入手。&lt;/p>
&lt;pre>&lt;code>% python3 get-pip.py --user
% export PATH=$HOME/.local/bin:$PATH # ~/.bashrc に追記しておく
% pip3 install mypy
&lt;/code>&lt;/pre></description></item><item><title>Twitter にブログ更新情報をポストします</title><link>https://blog2.issei.org/2020/08/28/twitter/</link><pubDate>Fri, 28 Aug 2020 21:36:29 +0200</pubDate><guid>https://blog2.issei.org/2020/08/28/twitter/</guid><description>&lt;p>今時 RSS でブログを読みに来る人もいないと思うので、
ブログの更新情報ポスト用に Twitter アカウント &lt;a href="https://twitter.com/issei_swe">@issei_swe&lt;/a> を作りました。&lt;/p>
&lt;p>ブログが更新されると、
自動的に Twitter に更新内容がポストされます。&lt;/p></description></item><item><title>ブロク作成環境を Jekyll に変更</title><link>https://blog2.issei.org/2020/08/13/welcome-to-jekyll/</link><pubDate>Thu, 13 Aug 2020 00:16:00 +0200</pubDate><guid>https://blog2.issei.org/2020/08/13/welcome-to-jekyll/</guid><description>&lt;p>これまで Web で公開したい文書は &lt;a href="https://www.blogger.com/">Blogger&lt;/a> で書いていましたが、
マークダウン記法が使える &lt;a href="https://jekyllrb.com/">Jekyll&lt;/a> と &lt;a href="http://pages.github.com/">GitHub Pages&lt;/a> に移行することにしました。&lt;/p>
&lt;p>追記: 後日さらに &lt;a href="https://gohugo.io">Hugo&lt;/a> に移行し、
このエントリも Hugo で出力されています。&lt;/p>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>Blogger は入力画面で見えるものが最終結果に近く書式設定もメニューから操作できるため分かりやすいですが、
一方で編集機能が弱いです。
そこで Google Docs などで下書きした文書をコピーしてくると、
今度は大量の書式指定が入った HTML になってしまい修正に手間がかかります。&lt;/p>
&lt;h3 id="blogger-の例">Blogger の例&lt;/h3>
&lt;h4 id="入力">入力&lt;/h4>
&lt;p>&lt;img src="https://blog2.issei.org/assets/2020/08/13/blogger_garbage_tags.png" alt="blogger HTMLコード">&lt;/p>
&lt;h4 id="出力">出力&lt;/h4>
&lt;p>&lt;img src="https://blog2.issei.org/assets/2020/08/13/blogger_screenshot.png" alt="blogger Web表示イメージ">&lt;/p>
&lt;h3 id="マークダウンの例">マークダウンの例&lt;/h3>
&lt;p>&lt;a href="https://jekyllrb.com/">Jekyll&lt;/a> はマークダウン記法で記事を書くと HTML に変換し、
同時に記事一覧などのページを作成するツールです。
凝ったデザインのページを作るには向きませんが、
構造化されたテキストを気楽に書けます。&lt;/p>
&lt;h4 id="入力-1">入力&lt;/h4>
&lt;pre>&lt;code>| | 所要日数 | 保障額 |
|-|-|-|
| 国際通常郵便（手紙・船便） | 1~3ヶ月 | なし |
| 国際通常郵便（手紙・SAL便） | 14日間 | 6000円 |
&lt;/code>&lt;/pre>&lt;h4 id="出力-1">出力&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>所要日数&lt;/th>
&lt;th>保障額&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>国際通常郵便（手紙・船便）&lt;/td>
&lt;td>1~3ヶ月&lt;/td>
&lt;td>なし&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>国際通常郵便（手紙・SAL便）&lt;/td>
&lt;td>14日間&lt;/td>
&lt;td>6000円&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="環境構築">環境構築&lt;/h2>
&lt;p>マークダウン記法で書いたテキストファイルを &lt;a href="http://pages.github.com/">GitHub Pages&lt;/a> にアップロードするだけでも公開できますが、私は&lt;/p>
&lt;ol>
&lt;li>自分の PC で記事を作成&lt;/li>
&lt;li>手元の環境で記事を HTML にして、意図通りに見えるか確認&lt;/li>
&lt;li>&lt;a href="http://pages.github.com/">GitHub Pages&lt;/a> にアップロードして公開&lt;/li>
&lt;/ol>
&lt;p>という手順にしたかったので、
手元の PC に &lt;a href="https://jekyllrb.com/">Jekyll&lt;/a> をインストールしてマークダウン記法のファイルから HTML を作れるようにしてみました。&lt;/p>
&lt;p>使っている PC は Google Pixelbook (2017) で、
スペックは次の通りです。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>OS&lt;/th>
&lt;th>CPU&lt;/th>
&lt;th>RAM&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>ChromeOS&lt;/td>
&lt;td>COre i7 (7th Gen)&lt;/td>
&lt;td>16GB&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;a href="https://jekyllrb.com/">Jekyll&lt;/a> は ChromeOS では動きませんが、
Pixelbook 上に &lt;a href="https://support.google.com/chromebook/answer/9145439">Linux（ベータ版）をセットアップ&lt;/a> できるので、
その Linux 環境上に &lt;a href="https://jekyllrb.com/">Jekyll&lt;/a> をセットアップしました。&lt;/p>
&lt;h3 id="ruby-271-のインストール">Ruby 2.7.1 のインストール&lt;/h3>
&lt;p>&lt;a href="https://jekyllrb.com/">Jekyll&lt;/a> を使うには Ruby バージョン 2.5.0 以上が必要です。&lt;/p>
&lt;p>Pixelbook は標準で APT パッケージマネージャーを使えるので、
これで Ruby をインストールしようと思ったのですが、&lt;/p>
&lt;pre>&lt;code>$ apt-cache showpkg ruby
Package: ruby
Versions:
1:2.3.3 (/var/lib/apt/lists/deb.debian.org_debian_dists_stretch_main_binary-amd64_Packages)
&lt;/code>&lt;/pre>&lt;p>残念ながら Ruby のバージョンが古いので使えません。&lt;/p>
&lt;p>調べたところ、rbenv を使うと任意のバージョンの Ruby をインストールでき、
バージョンの変更も容易とのこと。
&lt;a href="https://github.com/rbenv/rbenv#basic-github-checkout">Basic GitHub Checkout&lt;/a> の手順に従い &lt;code>~/.rbenv&lt;/code> 以下にファイルを展開し、
この時点で安定版として最新の 2.7.1 をインストールしました。&lt;/p>
&lt;pre>&lt;code>% rbenv install 2.7.1
&lt;/code>&lt;/pre>&lt;p>Ruby のソースコードを持ってきてビルドするので、
時間がかかります。
何度か Ruby 2.7.1 が依存するパッケージが不足しているということでビルドに失敗したので、
その都度パッケージを &lt;code>apt-get&lt;/code> コマンドでインストールして、最終的に Ruby のインストールに成功。&lt;/p>
&lt;pre>&lt;code>$ ruby -v
ruby 2.7.1p83 (2020-03-31 revision a0c7c23c9c) [x86_64-linux]
&lt;/code>&lt;/pre>&lt;h3 id="jekyll-のインストール">Jekyll のインストール&lt;/h3>
&lt;p>&lt;a href="http://pages.github.com/">GitHub Pages&lt;/a> の説明に従って GitHub Pages 用の Git リポジトリを作成し、
手元に clone してきます。
私は GitHub リポジトリへのアクセスに ssh を使っていますが、
HTTPS を使っている場合には URL が変わります。&lt;/p>
&lt;pre>&lt;code>% git clone git@github.com:$(GIT_USER)/$(GIT_USER).github.io
&lt;/code>&lt;/pre>&lt;p>手元に &lt;code>$(GIT_USER).github.io&lt;/code> というディレクトリができるので、
そこに移動して jekyll をセットアップします。&lt;/p>
&lt;pre>&lt;code>% cd $(GIT_USER).github.io
% bundle init
% bundle add github-pages
% bundle exec jekyll new . --force
&lt;/code>&lt;/pre>&lt;p>警告が出ますが Gemfiles が更新されていれば無視して大丈夫です。
こうして作成された Gemfiles をエディタで開いて、
下記のコメントに従って変更します。&lt;/p>
&lt;pre>&lt;code># If you want to use GitHub Pages, remove the &amp;quot;gem &amp;quot;jekyll&amp;quot;&amp;quot; above and
# uncomment the line below. To upgrade, run `bundle update github-pages`.
# gem &amp;quot;github-pages&amp;quot;, group: :jekyll_plugins
&lt;/code>&lt;/pre>&lt;p>最後に Gemfiles の変更を反映して終了です。&lt;/p>
&lt;pre>&lt;code>% bundle update github-pages
&lt;/code>&lt;/pre>&lt;h3 id="jekyll-の起動とテスト">Jekyll の起動とテスト&lt;/h3>
&lt;pre>&lt;code>% bundle exec jekyll s
&lt;/code>&lt;/pre>&lt;p>これで &lt;a href="https://jekyllrb.com/">Jekyll&lt;/a> が起動して、
各種設定ファイルや &lt;code>_post&lt;/code> ディレクトリ以下にある記事を処理して Web サイトを作成します。
&lt;a href="https://jekyllrb.com/">Jekyll&lt;/a> は HTML ファイル作成後も終了せず、
そのまま実行を続けます。&lt;/p>
&lt;ul>
&lt;li>ファイルの変更を監視し、_post や assert ディレクトリなどの内容が更新されると、HTML ファイルを再作成します。&lt;/li>
&lt;li>Web サーバとして機能し、作成したファイルを提供します。
ブラウザを開いて &lt;a href="http://localhost:4000/">http://localhost:4000/&lt;/a> にアクセスすることで、
&lt;a href="https://jekyllrb.com/">Jekyll&lt;/a> によって作成された Web ページを確認できます。&lt;/li>
&lt;/ul>
&lt;p>これで手元で Web ページを作成し、確認する環境が整いました。&lt;/p>
&lt;p>なお &lt;a href="https://jekyllrb.com/">Jekyll&lt;/a> はファイルが更新されると自動的に HTML ファイルを再作成しますが、
例外として、
設定ファイルである _config.yml は更新しても再作成処理を行いません。
_config.yml を変更した場合には &lt;a href="https://jekyllrb.com/">Jekyll&lt;/a> を一旦終了し、再度&lt;/p>
&lt;p>&lt;code>% bundle exec jekyll s&lt;/code>&lt;/p>
&lt;p>と実行する必要があります。&lt;/p></description></item></channel></rss>